// Code generated by cuelang.org/go/pkg/gen. DO NOT EDIT.

package math

import (
	"cuelang.org/go/internal/core/adt"
	"cuelang.org/go/pkg/internal"

	_ "embed"
)

func init() {
	internal.Register("math", pkg)
}

//go:embed pkg.cue
var cueDecls string

var _ = adt.TopKind // in case the adt package isn't used

var pkg = &internal.Package{
	Funcs: map[string]func(c *internal.CallCtxt){
		"Jacobi": func(c *internal.CallCtxt) {
			x, y := c.BigInt(0), c.BigInt(1)
			if c.Do() {
				c.Ret = Jacobi(x, y)
			}
		},
		"Floor": func(c *internal.CallCtxt) {
			x := c.Decimal(0)
			if c.Do() {
				c.Ret, c.Err = Floor(x)
			}
		},
		"Ceil": func(c *internal.CallCtxt) {
			x := c.Decimal(0)
			if c.Do() {
				c.Ret, c.Err = Ceil(x)
			}
		},
		"Trunc": func(c *internal.CallCtxt) {
			x := c.Decimal(0)
			if c.Do() {
				c.Ret, c.Err = Trunc(x)
			}
		},
		"Round": func(c *internal.CallCtxt) {
			x := c.Decimal(0)
			if c.Do() {
				c.Ret, c.Err = Round(x)
			}
		},
		"RoundToEven": func(c *internal.CallCtxt) {
			x := c.Decimal(0)
			if c.Do() {
				c.Ret, c.Err = RoundToEven(x)
			}
		},
		"MultipleOf": func(c *internal.CallCtxt) {
			x, y := c.Decimal(0), c.Decimal(1)
			if c.Do() {
				c.Ret, c.Err = MultipleOf(x, y)
			}
		},
		"Abs": func(c *internal.CallCtxt) {
			x := c.Decimal(0)
			if c.Do() {
				c.Ret, c.Err = Abs(x)
			}
		},
		"Acosh": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Acosh(x)
			}
		},
		"Asin": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Asin(x)
			}
		},
		"Acos": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Acos(x)
			}
		},
		"Asinh": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Asinh(x)
			}
		},
		"Atan": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Atan(x)
			}
		},
		"Atan2": func(c *internal.CallCtxt) {
			y, x := c.Float64(0), c.Float64(1)
			if c.Do() {
				c.Ret = Atan2(y, x)
			}
		},
		"Atanh": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Atanh(x)
			}
		},
		"Cbrt": func(c *internal.CallCtxt) {
			x := c.Decimal(0)
			if c.Do() {
				c.Ret, c.Err = Cbrt(x)
			}
		},
		"Copysign": func(c *internal.CallCtxt) {
			x, y := c.Decimal(0), c.Decimal(1)
			if c.Do() {
				c.Ret = Copysign(x, y)
			}
		},
		"Dim": func(c *internal.CallCtxt) {
			x, y := c.Decimal(0), c.Decimal(1)
			if c.Do() {
				c.Ret, c.Err = Dim(x, y)
			}
		},
		"Erf": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Erf(x)
			}
		},
		"Erfc": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Erfc(x)
			}
		},
		"Erfinv": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Erfinv(x)
			}
		},
		"Erfcinv": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Erfcinv(x)
			}
		},
		"Exp": func(c *internal.CallCtxt) {
			x := c.Decimal(0)
			if c.Do() {
				c.Ret, c.Err = Exp(x)
			}
		},
		"Exp2": func(c *internal.CallCtxt) {
			x := c.Decimal(0)
			if c.Do() {
				c.Ret, c.Err = Exp2(x)
			}
		},
		"Expm1": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Expm1(x)
			}
		},
		"Gamma": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Gamma(x)
			}
		},
		"Hypot": func(c *internal.CallCtxt) {
			p, q := c.Float64(0), c.Float64(1)
			if c.Do() {
				c.Ret = Hypot(p, q)
			}
		},
		"J0": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = J0(x)
			}
		},
		"Y0": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Y0(x)
			}
		},
		"J1": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = J1(x)
			}
		},
		"Y1": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Y1(x)
			}
		},
		"Jn": func(c *internal.CallCtxt) {
			n, x := c.Int(0), c.Float64(1)
			if c.Do() {
				c.Ret = Jn(n, x)
			}
		},
		"Yn": func(c *internal.CallCtxt) {
			n, x := c.Int(0), c.Float64(1)
			if c.Do() {
				c.Ret = Yn(n, x)
			}
		},
		"Ldexp": func(c *internal.CallCtxt) {
			frac, exp := c.Float64(0), c.Int(1)
			if c.Do() {
				c.Ret = Ldexp(frac, exp)
			}
		},
		"Log": func(c *internal.CallCtxt) {
			x := c.Decimal(0)
			if c.Do() {
				c.Ret, c.Err = Log(x)
			}
		},
		"Log10": func(c *internal.CallCtxt) {
			x := c.Decimal(0)
			if c.Do() {
				c.Ret, c.Err = Log10(x)
			}
		},
		"Log2": func(c *internal.CallCtxt) {
			x := c.Decimal(0)
			if c.Do() {
				c.Ret, c.Err = Log2(x)
			}
		},
		"Log1p": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Log1p(x)
			}
		},
		"Logb": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Logb(x)
			}
		},
		"Ilogb": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Ilogb(x)
			}
		},
		"Mod": func(c *internal.CallCtxt) {
			x, y := c.Float64(0), c.Float64(1)
			if c.Do() {
				c.Ret = Mod(x, y)
			}
		},
		"Pow": func(c *internal.CallCtxt) {
			x, y := c.Decimal(0), c.Decimal(1)
			if c.Do() {
				c.Ret, c.Err = Pow(x, y)
			}
		},
		"Pow10": func(c *internal.CallCtxt) {
			n := c.Int32(0)
			if c.Do() {
				c.Ret = Pow10(n)
			}
		},
		"Remainder": func(c *internal.CallCtxt) {
			x, y := c.Float64(0), c.Float64(1)
			if c.Do() {
				c.Ret = Remainder(x, y)
			}
		},
		"Signbit": func(c *internal.CallCtxt) {
			x := c.Decimal(0)
			if c.Do() {
				c.Ret = Signbit(x)
			}
		},
		"Cos": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Cos(x)
			}
		},
		"Sin": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Sin(x)
			}
		},
		"Sinh": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Sinh(x)
			}
		},
		"Cosh": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Cosh(x)
			}
		},
		"Sqrt": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Sqrt(x)
			}
		},
		"Tan": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Tan(x)
			}
		},
		"Tanh": func(c *internal.CallCtxt) {
			x := c.Float64(0)
			if c.Do() {
				c.Ret = Tanh(x)
			}
		},
	},
	CUE: cueDecls,
}

package main

import (
	"bytes"
	_ "embed"
	"flag"
	"fmt"
	"go/ast"
	gobuild "go/build"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"

	"cuelang.org/go/cue"
	"cuelang.org/go/cue/build"
	"cuelang.org/go/cue/errors"
	cueformat "cuelang.org/go/cue/format"
	"cuelang.org/go/internal/core/runtime"
)

const genFile = "pkg.go"

// Note: we avoid using the cue/load and the cuecontext packages
// because they depend on the standard library which is what this
// command is generating - cyclic dependencies are undesirable in general.
var cueCtxt = newContext()

//go:embed builtin.cue
var builtinSchemaStr string

var builtinSchema = func() cue.Value {
	val := cueCtxt.CompileString(builtinSchemaStr, cue.Filename("builtin.cue"))
	if err := val.Err(); err != nil {
		panic(err)
	}
	return val
}()

var commentDeclSchema = builtinSchema.LookupPath(cue.MakePath(cue.Def("#CommentDecl")))

type headerParams struct {
	GenFile string
	GoPkg   string
	CUEPkg  string
}

var header = template.Must(template.New("").Parse(`// Code generated by cuelang.org/go/pkg/gen. DO NOT EDIT.

package {{.GoPkg}}

import (
	"cuelang.org/go/internal/core/adt"
	"cuelang.org/go/pkg/internal"
)

func init() {
	internal.Register({{printf "%q" .CUEPkg}}, pkg)
}

var _ = adt.TopKind // in case the adt package isn't used

`))

func main() {
	flag.Parse()
	log.SetFlags(log.Lshortfile)
	log.SetOutput(os.Stdout)

	if err := generate("net"); err != nil {
		log.Fatalf("cannot generate: %v", err)
	}
}

type generator struct {
	dir        string
	w          *bytes.Buffer
	cuePkgPath string
	fset       *token.FileSet
	exports    map[string]cue.Value
	scope      cue.Value
}

func generate(cuePkgPath string) error {
	goPkgPath := path.Join("cuelang.org/go/pkg", cuePkgPath)
	pkg, err := gobuild.Import(goPkgPath, "", 0)
	if err != nil {
		return err
	}

	g := generator{
		dir:        pkg.Dir,
		cuePkgPath: cuePkgPath,
		w:          &bytes.Buffer{},
		fset:       token.NewFileSet(),
		exports:    make(map[string]cue.Value),
	}

	scope, err := loadCUEPackage(cueCtxt, g.dir, g.cuePkgPath)
	if err != nil {
		if !errors.Is(err, errNoCUEFiles) {
			errors.Print(os.Stderr, err, nil)
			return fmt.Errorf("error processing %s: %v", g.cuePkgPath, err)
		}
		scope = cueCtxt.CompileString("_")
	}
	g.scope = scope

	for _, filename := range pkg.GoFiles {
		if filename == genFile {
			continue
		}
		if err := g.processGo(filepath.Join(pkg.Dir, filename)); err != nil {
			return err
		}
	}
	if err := g.processCUE(); err != nil {
		return err
	}
	fmt.Printf("%s\n", g.w.Bytes())
	return nil
}

// processCUE mixes in CUE definitions defined in the package directory.
func (g *generator) processCUE() error {
	// Note: we avoid using the cue/load and the cuecontext packages
	// because they depend on the standard library which is what this
	// command is generating - cyclic dependencies are undesirable in general.

	final := g.scope.FillPath(cue.MakePath(cue.Str("exports")), g.exports)
	v := final.Syntax(cue.Raw(), cue.Definitions(true))
	b, err := cueformat.Node(v)
	if err != nil {
		return err
	}
	fmt.Fprintf(g.w, "%s\n", b)
	return nil
}

func (g *generator) processGo(filename string) error {
	f, err := parser.ParseFile(g.fset, filename, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	for _, d := range f.Decls {
		switch x := d.(type) {
		case *ast.FuncDecl:
			if x.Name.Name != "ToIP4" {
				continue
			}
			if err := g.genFunc(x); err != nil {
				return fmt.Errorf("%s: %v", x.Name.Name, err)
			}
		}
	}
	return nil
}

func (g *generator) genFunc(x *ast.FuncDecl) error {
	decl := commentDeclSchema
	if c := cueDeclFromComment(x.Doc); c != "" {
		commentDecl := cueCtxt.CompileString(c, cue.Scope(g.scope))
		if err := commentDecl.Err(); err != nil {
			// TODO include source location of error.
			return fmt.Errorf("cannot parse CUE in comment for %v: %v", x.Name.Name, err)
		}
		decl = decl.Unify(commentDecl)
		if err := decl.Err(); err != nil {
			// TODO include source location of error.
			return fmt.Errorf("conflict in CUE for %v: %v", x.Name.Name, err)
		}

	}
	types := []string{}
	if x.Type.Results != nil {
		for _, f := range x.Type.Results.List {
			if len(f.Names) > 0 {
				for range f.Names {
					types = append(types, g.goKind(f.Type))
				}
			} else {
				types = append(types, g.goKind(f.Type))
			}
		}
	}
	if n := len(types); n != 1 && (n != 2 || types[1] != "error") {
		fmt.Printf("Dropped func %s.%s: must have one return value or a value and an error %v\n", g.cuePkgPath, x.Name.Name, types)
		return nil
	}

	args := []string{}
	for _, f := range x.Type.Params.List {
		for _, name := range f.Names {
			args = append(args, name.Name)

			decl = decl.FillPath(cue.MakePath(cue.Str("in"), cue.Str(name.Name)), g.goToCUE(f.Type))
		}
	}

	expr := x.Type.Results.List[0].Type
	decl = decl.FillPath(cue.MakePath(cue.Str("out")), g.goToCUE(expr))
	if err := decl.Validate(); err != nil {
		return err
	}

	// Now convert from the struct form of the args to the list form that
	// we'll include in the output CUE.
	decl, err := commentDeclToFuncDecl(decl, args)
	if err != nil {
		return err
	}
	g.exports[x.Name.Name] = decl
	return nil
}

// funcArg
type funcArg struct {
	Name string    `json:"name"`
	Type cue.Value `json:"type"`
}

// commentDeclToFuncDecl converts from the object form found in the cue:
// commands to the ordered list that's exposed in the output CUE.
func commentDeclToFuncDecl(v cue.Value, args []string) (cue.Value, error) {
	decl := builtinSchema.LookupPath(cue.MakePath(cue.Def("#Func")))
	decl = decl.FillPath(cue.MakePath(cue.Str("out")), v.LookupPath(cue.MakePath(cue.Str("out"))))
	argPos := make(map[string]int)
	for i, arg := range args {
		argPos[arg] = i
	}
	argVals := make([]*funcArg, len(args))
	iter, err := v.LookupPath(cue.MakePath(cue.Str("in"))).Fields()
	if err != nil {
		return cue.Value{}, err
	}
	for iter.Next() {
		// Note: this is OK because we know all arguments should be valid Go
		// identifiers which are also valid CUE identifiers.
		arg := iter.Selector().String()
		i, ok := argPos[arg]
		if !ok {
			return cue.Value{}, fmt.Errorf("no Go argument %q found in %#v", arg, argPos)
		}
		argVals[i] = &funcArg{
			Name: arg,
			Type: iter.Value(),
		}
	}
	decl = decl.FillPath(cue.MakePath(cue.Str("in")), argVals)
	if err := decl.Validate(); err != nil {
		return cue.Value{}, err
	}
	fmt.Printf("all args: %v", cueStr(decl))
	return decl, nil
}

func cueStr(val cue.Value) string {
	data, err := cueformat.Node(val.Syntax(cue.Raw(), cue.Definitions(true)))
	if err != nil {
		panic(err)
	}
	return string(data)
}

func cueDeclFromComment(cg *ast.CommentGroup) string {
	inCUE := false
	var cueText strings.Builder
	for _, c := range cg.List {
		if !inCUE {
			if !strings.HasPrefix(c.Text, "//cue:") {
				continue
			}
			txt := strings.TrimPrefix(c.Text, "//cue:")
			what, rest, _ := cut(txt, " ")
			switch what {
			case "func":
				if rest != "" {
					fmt.Fprintln(&cueText, rest)
				}
			default:
				panic(fmt.Errorf("unrecognized cue: comment directive: %q", c.Text))
				// TODO support "constraint" too.
			}
			inCUE = true
			continue
		}
		if !strings.HasPrefix(c.Text, "//") {
			// TODO support /* */ comments?
			continue
		}
		cueText.WriteString(c.Text[2:])
		cueText.WriteByte('\n')
	}
	return cueText.String()
}

func (g *generator) goKind(expr ast.Expr) string {
	if star, isStar := expr.(*ast.StarExpr); isStar {
		expr = star.X
	}
	w := &bytes.Buffer{}
	printer.Fprint(w, g.fset, expr)
	switch str := w.String(); str {
	case "big.Int":
		return "bigInt"
	case "big.Float":
		return "bigFloat"
	case "big.Rat":
		return "bigRat"
	case "adt.Bottom":
		return "error"
	case "internal.Decimal":
		return "decimal"
	case "[]*internal.Decimal":
		return "decimalList"
	case "cue.Struct":
		return "struct"
	case "cue.Value":
		return "value"
	case "cue.List":
		return "list"
	case "[]string":
		return "stringList"
	case "[]byte":
		return "bytes"
	case "[]cue.Value":
		return "list"
	case "io.Reader":
		return "reader"
	case "time.Time":
		return "string"
	default:
		return str
	}
}

func (g *generator) goToCUE(expr ast.Expr) cue.Value {
	cueStr := "_"
	switch k := g.goKind(expr); k {
	case "bool",
		"string",
		"int8", "int16", "int32", "int64",
		"uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		cueStr = k
	case "int":
		cueStr = "int64"
	case "uint":
		cueStr = "uint64"
	case "byte":
		cueStr = "uint8"
	case "rune":
		cueStr = "int32"
	case "bigInt":
		cueStr = "int"
	case "bytes", "reader":
		cueStr = "bytes|string"
	case "bigRat", "bigFloat", "decimal":
		cueStr = "number"
	case "list":
		cueStr = "[...]"
	case "decimalList":
		cueStr = "[... number]"
	case "stringList":
		cueStr = "[... string]"
	case "struct":
		cueStr = "{...}"
	case "value":
		cueStr = "_"
	default:
		switch {
		case strings.HasPrefix(k, "[]"):
			cueStr = "[...]"
		case strings.HasPrefix(k, "map["):
			cueStr = "{...}"
		}
	}
	v := cueCtxt.CompileString(cueStr)
	if err := v.Err(); err != nil {
		panic(err)
	}
	return v
}

var errNoCUEFiles = errors.New("no CUE files in directory")

// loadCUEPackage loads a CUE package as a value. We avoid using cue/load because
// that depends on the standard library and as this generator is generating the standard
// library, we don't want that cyclic dependency.
// It only has to deal with the fairly limited subset of CUE packages that are
// present inside pkg/....
func loadCUEPackage(ctx *cue.Context, dir string, pkgPath string) (cue.Value, error) {
	inst := &build.Instance{
		PkgName:     path.Base(pkgPath),
		Dir:         dir,
		DisplayPath: pkgPath,
		ImportPath:  pkgPath,
	}
	cuefiles, err := filepath.Glob(filepath.Join(dir, "*.cue"))
	if err != nil {
		return cue.Value{}, err
	}
	if len(cuefiles) == 0 {
		return cue.Value{}, errNoCUEFiles
	}
	for _, file := range cuefiles {
		if err := inst.AddFile(file, nil); err != nil {
			return cue.Value{}, err
		}
	}
	if err := inst.Complete(); err != nil {
		return cue.Value{}, err
	}
	vals, err := ctx.BuildInstances([]*build.Instance{inst})
	if err != nil {
		return cue.Value{}, err
	}
	return vals[0], nil
}

// Avoid using cuecontext.New because that package imports
// the entire stdlib which we are generating.
func newContext() *cue.Context {
	r := runtime.New()
	return (*cue.Context)(r)
}

// strings.Cut
func cut(s, sep string) (before, after string, found bool) {
	if i := strings.Index(s, sep); i >= 0 {
		return s[:i], s[i+len(sep):], true
	}
	return s, "", false
}

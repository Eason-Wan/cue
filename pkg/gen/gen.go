// Copyright 2018 The CUE Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package gen generates the pkg.go files inside the packages under the pkg directory.
//
// It takes the list of packages from the packages.txt.
//
// Be sure to also update an entry in pkg/pkg.go, if so desired.
// TODO update pkg/registry.go too.
package main

import (
	"bytes"
	_ "embed"
	"flag"
	"fmt"
	goast "go/ast"
	gobuild "go/build"
	goconstant "go/constant"
	goformat "go/format"
	goparser "go/parser"
	goprinter "go/printer"
	gotoken "go/token"
	"io/ioutil"
	"log"
	"math/big"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"

	"cuelang.org/go/cue"
	"cuelang.org/go/cue/ast"
	"cuelang.org/go/cue/build"
	"cuelang.org/go/cue/errors"
	"cuelang.org/go/cue/format"
	"cuelang.org/go/cue/parser"
	"cuelang.org/go/cue/token"
	"cuelang.org/go/internal/core/runtime"
)

const genFile = "pkg.go"

//go:embed packages.txt
var packagesStr string

var packages = strings.Fields(packagesStr)

// Note: we avoid using the cue/load and the cuecontext packages
// because they depend on the standard library which is what this
// command is generating - cyclic dependencies are undesirable in general.
var cueCtxt = newContext()

//go:embed builtin.cue
var builtinSchemaStr string

var builtinSchema = func() cue.Value {
	val := cueCtxt.CompileString(builtinSchemaStr, cue.Filename("builtin.cue"))
	if err := val.Err(); err != nil {
		panic(err)
	}
	return val
}()

var commentDeclSchema = builtinSchema.LookupPath(cue.MakePath(cue.Def("#CommentDecl")))

const alwaysIncludeInferredDecl = true

type headerParams struct {
	GenFile string
	GoPkg   string
	CUEPkg  string
}

var header = template.Must(template.New("").Parse(`// Code generated by cuelang.org/go/pkg/gen. DO NOT EDIT.

package {{.GoPkg}}

import (
	"cuelang.org/go/internal/core/adt"
	"cuelang.org/go/pkg/internal"

	_ "embed"
)

func init() {
	internal.Register({{printf "%q" .CUEPkg}}, pkg)
}

//go:embed pkg.cue
var cueDecls string

var _ = adt.TopKind // in case the adt package isn't used

`))

func main() {
	flag.Parse()
	log.SetFlags(log.Lshortfile)
	log.SetOutput(os.Stdout)

	for _, pkg := range packages {
		if err := generate(pkg); err != nil {
			log.Printf("%s: %v", pkg, err)
		}
	}
}

type generator struct {
	dir        string
	w          *bytes.Buffer
	cuePkgPath string
	fset       *gotoken.FileSet
	exports    *ast.StructLit
	cuePkg     cue.Value
}

func generate(cuePkgPath string) error {
	goPkgPath := path.Join("cuelang.org/go/pkg", cuePkgPath)
	gopkg, err := gobuild.Import(goPkgPath, "", 0)
	if err != nil {
		return err
	}

	g := generator{
		dir:        gopkg.Dir,
		cuePkgPath: cuePkgPath,
		w:          &bytes.Buffer{},
		fset:       gotoken.NewFileSet(),
		exports:    &ast.StructLit{},
	}

	cuePkg, err := loadCUEPackage(cueCtxt, g.dir, g.cuePkgPath)
	if err != nil {
		if !errors.Is(err, errNoCUEFiles) {
			errors.Print(os.Stderr, err, nil)
			return fmt.Errorf("error processing %s: %v", g.cuePkgPath, err)
		}
	}
	g.cuePkg = cuePkg

	if err := header.Execute(g.w, headerParams{
		GenFile: genFile,
		GoPkg:   gopkg.Name,
		CUEPkg:  cuePkgPath,
	}); err != nil {
		return err
	}

	fmt.Fprintf(g.w, "var pkg = &internal.Package{\n")
	fmt.Fprintf(g.w, "Funcs: map[string] func(c *internal.CallCtxt) {\n")
	for _, filename := range gopkg.GoFiles {
		if filename == genFile {
			continue
		}
		if err := g.processGo(filepath.Join(gopkg.Dir, filename)); err != nil {
			return err
		}
	}
	fmt.Fprintf(g.w, "},\n")
	fmt.Fprintf(g.w, "CUE: cueDecls,\n")
	fmt.Fprintf(g.w, "}\n")

	filename := filepath.Join(g.dir, genFile)

	b, err := goformat.Source(g.w.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s:%v\n", filename, err)
		b = g.w.Bytes() // write the unformatted source
	}

	if err := ioutil.WriteFile(filename, b, 0666); err != nil {
		return err
	}
	if err := g.processCUE(); err != nil {
		return err
	}
	return nil
}

// processCUE mixes in CUE definitions defined in the package directory.
func (g *generator) processCUE() error {
	// Note: we avoid using the cue/load and the cuecontext packages
	// because they depend on the standard library which is what this
	// command is generating - cyclic dependencies are undesirable in general.

	var f *ast.File
	if g.cuePkg.Context() != nil {
		syntax := g.cuePkg.Syntax(cue.Raw(), cue.Definitions(true), cue.Docs(true))
		var ok bool
		f, ok = syntax.(*ast.File)
		if !ok {
			return fmt.Errorf("did not get expected *ast.File from syntax %T", syntax)
		}
	} else {
		f = &ast.File{
			Decls: []ast.Decl{
				&ast.Package{
					Name: &ast.Ident{
						Name: path.Base(g.cuePkgPath),
					},
				},
			},
		}
	}
	// TODO we want to make this comment a file-level comment, not a doc
	// comment, but it's not clear how to do that (maybe we need to populate position
	// info?)
	f.AddComment(&ast.CommentGroup{
		List: []*ast.Comment{{
			Text: "// Code generated by cuelang.org/go/pkg/gen. DO NOT EDIT.",
		}},
	})
	f.Decls = append(f.Decls, g.exports.Elts...)

	b, err := format.Node(f)
	if err != nil {
		return err
	}
	filename := filepath.Join(g.dir, "pkg.cue")
	if err := os.WriteFile(filename, b, 0o666); err != nil {
		return err
	}
	return nil
}

func (g *generator) processGo(filename string) error {
	f, err := goparser.ParseFile(g.fset, filename, nil, goparser.ParseComments)
	if err != nil {
		return err
	}

	for _, d := range f.Decls {
		switch x := d.(type) {
		case *goast.GenDecl:
			switch x.Tok {
			case gotoken.CONST:
				for _, spec := range x.Specs {
					spec := spec.(*goast.ValueSpec)
					if goast.IsExported(spec.Names[0].Name) {
						g.genValue(spec)
					}
				}
			case gotoken.VAR:
				continue
			case gotoken.TYPE:
				// TODO: support type declarations.
				continue
			case gotoken.IMPORT:
				continue
			default:
				panic(fmt.Errorf("gen %s: unexpected spec of type %s", filename, x.Tok))
			}
		case *goast.FuncDecl:
			if x.Body != nil && x.Recv == nil && goast.IsExported(x.Name.Name) {
				if err := g.genFunc(x); err != nil {
					return fmt.Errorf("%s: %v", x.Name.Name, err)
				}
			}
		}
	}
	return nil
}

func (g *generator) genValue(spec *goast.ValueSpec) {
	name := spec.Names[0].Name
	value := ""
	switch v := g.toValue(spec.Values[0]); v.Kind() {
	case goconstant.Bool, goconstant.Int, goconstant.String:
		// TODO: convert octal numbers
		value = v.ExactString()
	case goconstant.Float:
		var rat big.Rat
		rat.SetString(v.ExactString())
		var float big.Float
		float.SetRat(&rat)
		value = float.Text('g', -1)
	default:
		fmt.Printf("Dropped entry %s.%s (%T: %v)\n", g.cuePkgPath, name, v.Kind(), v.ExactString())
		return
	}
	expr, err := parser.ParseExpr("", value)
	if err != nil {
		panic(fmt.Errorf("cannot parse %q: %v", value, err))
	}
	g.addExportValue(name, expr)
}

func (g *generator) toValue(x goast.Expr) goconstant.Value {
	switch x := x.(type) {
	case *goast.BasicLit:
		return goconstant.MakeFromLiteral(x.Value, x.Kind, 0)
	case *goast.BinaryExpr:
		return goconstant.BinaryOp(g.toValue(x.X), x.Op, g.toValue(x.Y))
	case *goast.UnaryExpr:
		return goconstant.UnaryOp(x.Op, g.toValue(x.X), 0)
	default:
		panic(fmt.Errorf("%s: unsupported expression type %T: %#v", g.cuePkgPath, x, x))
	}
	return goconstant.MakeUnknown()
}

func (g *generator) genFunc(x *goast.FuncDecl) error {
	var decl *ast.StructLit
	var hasCommentDecl = false
	if c := cueDeclFromComment(x.Doc); c != "" {
		// TODO it would be nice if we could change the returned errors
		// so that they point to the correct place in the source Go file.
		decl1, err := parser.ParseExpr("", c, parser.ParseComments)
		if err != nil {
			return err
		}
		var ok bool
		decl, ok = decl1.(*ast.StructLit)
		if !ok {
			return fmt.Errorf("doc comment does not contain struct literal")
		}
		hasCommentDecl = true
	}
	types := []string{}
	if x.Type.Results != nil {
		for _, f := range x.Type.Results.List {
			if len(f.Names) > 0 {
				for range f.Names {
					types = append(types, g.goKind(f.Type))
				}
			} else {
				types = append(types, g.goKind(f.Type))
			}
		}
	}
	if n := len(types); n != 1 && (n != 2 || types[1] != "error") {
		fmt.Printf("Dropped func %s.%s: must have one return value or a value and an error %v\n", g.cuePkgPath, x.Name.Name, types)
		return nil
	}

	fmt.Fprintf(g.w, "%q: func(c *internal.CallCtxt) {\n", x.Name.Name)
	defer fmt.Fprintln(g.w, "},")

	args := []string{}
	vals := []string{}
	in := &ast.StructLit{}
	for _, f := range x.Type.Params.List {
		for _, name := range f.Names {
			typ := strings.Title(g.goKind(f.Type))
			in.Elts = append(in.Elts, astField(fmt.Sprintf("#A%d", len(args)), g.goTypeToCUE(f.Type)))
			vals = append(vals, fmt.Sprintf("c.%s(%d)", typ, len(args)))
			args = append(args, name.Name)
		}
	}
	out := g.goTypeToCUE(x.Type.Results.List[0].Type)

	if decl == nil {
		decl = &ast.StructLit{}
	}
	if !hasCommentDecl || alwaysIncludeInferredDecl {
		decl.Elts = append(decl.Elts,
			astField("in", in),
			astField("out", out),
		)
	}
	g.addExportFunc(x.Name.Name, decl)

	argList := strings.Join(args, ", ")
	if len(args) > 0 {
		fmt.Fprintf(g.w, "%s := %s\n", argList, strings.Join(vals, ", "))
	}
	fmt.Fprintln(g.w, "if c.Do() {")
	defer fmt.Fprintln(g.w, "}")
	if len(types) == 1 {
		fmt.Fprintf(g.w, "c.Ret = %s(%s)\n", x.Name.Name, argList)
	} else {
		fmt.Fprintf(g.w, "c.Ret, c.Err = %s(%s)\n", x.Name.Name, argList)
	}
	return nil
}

func (g *generator) addExportValue(name string, value ast.Expr) {
	g.exports.Elts = append(g.exports.Elts, astField(name, value))
}

func (g *generator) addExportFunc(name string, value ast.Expr) {
	g.exports.Elts = append(g.exports.Elts, astField("funcs", &ast.StructLit{
		Elts: []ast.Decl{astField(name, value)},
	}))
}

func cueStr(val cue.Value) string {
	data, err := format.Node(val.Syntax(cue.Raw(), cue.Definitions(true), cue.Docs(true)))
	if err != nil {
		panic(err)
	}
	return string(data)
}

func cueDeclFromComment(cg *goast.CommentGroup) string {
	inCUE := false
	var cueText strings.Builder
	for _, c := range cg.List {
		if !inCUE {
			if !strings.HasPrefix(c.Text, "//cue:") {
				continue
			}
			txt := strings.TrimPrefix(c.Text, "//cue:")
			what, rest, _ := cut(txt, " ")
			switch what {
			case "func":
				if rest != "" {
					fmt.Fprintln(&cueText, rest)
				}
			default:
				panic(fmt.Errorf("unrecognized cue: comment directive: %q", c.Text))
				// TODO support "constraint" too.
			}
			inCUE = true
			continue
		}
		if !strings.HasPrefix(c.Text, "//") {
			// TODO support /* */ comments?
			continue
		}
		cueText.WriteString(c.Text[2:])
		cueText.WriteByte('\n')
	}
	return cueText.String()
}

func (g *generator) goKind(expr goast.Expr) string {
	if star, isStar := expr.(*goast.StarExpr); isStar {
		expr = star.X
	}
	w := &bytes.Buffer{}
	goprinter.Fprint(w, g.fset, expr)
	switch str := w.String(); str {
	case "big.Int":
		return "bigInt"
	case "big.Float":
		return "bigFloat"
	case "big.Rat":
		return "bigRat"
	case "adt.Bottom":
		return "error"
	case "internal.Decimal":
		return "decimal"
	case "[]*internal.Decimal":
		return "decimalList"
	case "cue.Struct":
		return "struct"
	case "cue.Value":
		return "value"
	case "cue.List":
		return "list"
	case "[]string":
		return "stringList"
	case "[]byte":
		return "bytes"
	case "[]cue.Value":
		return "list"
	case "io.Reader":
		return "reader"
	case "time.Time":
		return "string"
	default:
		return str
	}
}

func (g *generator) goTypeToCUE(expr goast.Expr) ast.Expr {
	cueStr := "_"
	switch k := g.goKind(expr); k {
	case "bool",
		"string",
		"int8", "int16", "int32", "int64",
		"uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		cueStr = k
	case "int":
		cueStr = "int64"
	case "uint":
		cueStr = "uint64"
	case "byte":
		cueStr = "uint8"
	case "rune":
		cueStr = "int32"
	case "bigInt":
		cueStr = "int"
	case "bytes", "reader":
		cueStr = "bytes|string"
	case "bigRat", "bigFloat", "decimal":
		cueStr = "number"
	case "list":
		cueStr = "[...]"
	case "decimalList":
		cueStr = "[... number]"
	case "stringList":
		cueStr = "[... string]"
	case "struct":
		cueStr = "{...}"
	case "value":
		cueStr = "_"
	default:
		switch {
		case strings.HasPrefix(k, "[]"):
			cueStr = "[...]"
		case strings.HasPrefix(k, "map["):
			cueStr = "{...}"
		}
	}
	cueExpr, err := parser.ParseExpr("", cueStr)
	if err != nil {
		panic(err)
	}
	return cueExpr
}

var errNoCUEFiles = errors.New("no CUE files in directory")

// loadCUEPackage loads a CUE package as a value. We avoid using cue/load because
// that depends on the standard library and as this generator is generating the standard
// library, we don't want that cyclic dependency.
// It only has to deal with the fairly limited subset of CUE packages that are
// present inside pkg/....
func loadCUEPackage(ctx *cue.Context, dir string, pkgPath string) (cue.Value, error) {
	inst := &build.Instance{
		PkgName:     path.Base(pkgPath),
		Dir:         dir,
		DisplayPath: pkgPath,
		ImportPath:  pkgPath,
	}
	cuefiles, err := filepath.Glob(filepath.Join(dir, "*.cue"))
	if err != nil {
		return cue.Value{}, err
	}
	added := false
	for _, file := range cuefiles {
		if filepath.Base(file) == "pkg.cue" {
			// Ignore the file we're about to generate.
			continue
		}
		if err := inst.AddFile(file, nil); err != nil {
			return cue.Value{}, err
		}
		added = true
	}
	if !added {
		return cue.Value{}, errNoCUEFiles
	}
	if err := inst.Complete(); err != nil {
		return cue.Value{}, err
	}
	vals, err := ctx.BuildInstances([]*build.Instance{inst})
	if err != nil {
		return cue.Value{}, err
	}
	return vals[0], nil
}

func astField(label string, val ast.Expr) ast.Decl {
	return &ast.Field{
		Label: &ast.Ident{
			// We want the printer to collapse fields if possible,
			// producing (for example, `a: b: 1` rather than `a: {b: 1}`),
			// and the heuristic the printer uses is that it will do that
			// when the label's position is valid and there's no lbrace
			// position, so use an arbitrary position to trigger that logic.
			NamePos: somePos,
			Name:    label,
		},
		Token: token.COLON,
		Value: val,
	}
}

func astString(s string) *ast.BasicLit {
	return &ast.BasicLit{
		Kind:  token.STRING,
		Value: fmt.Sprintf("%q", s),
	}
}

var somePos = token.RelPos(1).Pos()

// Avoid using cuecontext.New because that package imports
// the entire stdlib which we are generating.
func newContext() *cue.Context {
	return (*cue.Context)(runtime.New())
}

// strings.Cut
func cut(s, sep string) (before, after string, found bool) {
	if i := strings.Index(s, sep); i >= 0 {
		return s[:i], s[i+len(sep):], true
	}
	return s, "", false
}

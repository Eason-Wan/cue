// Code generated by cuelang.org/go/pkg/gen. DO NOT EDIT.

package strings

import (
	"cuelang.org/go/internal/core/adt"
	"cuelang.org/go/pkg/internal"

	_ "embed"
)

func init() {
	internal.Register("strings", pkg)
}

//go:embed pkg.cue
var cueDecls string

var _ = adt.TopKind // in case the adt package isn't used

var pkg = &internal.Package{
	Funcs: map[string]func(c *internal.CallCtxt){
		"ByteAt": func(c *internal.CallCtxt) {
			b, i := c.Bytes(0), c.Int(1)
			if c.Do() {
				c.Ret, c.Err = ByteAt(b, i)
			}
		},
		"ByteSlice": func(c *internal.CallCtxt) {
			b, start, end := c.Bytes(0), c.Int(1), c.Int(2)
			if c.Do() {
				c.Ret, c.Err = ByteSlice(b, start, end)
			}
		},
		"Runes": func(c *internal.CallCtxt) {
			s := c.String(0)
			if c.Do() {
				c.Ret = Runes(s)
			}
		},
		"MinRunes": func(c *internal.CallCtxt) {
			s, min := c.String(0), c.Int(1)
			if c.Do() {
				c.Ret = MinRunes(s, min)
			}
		},
		"MaxRunes": func(c *internal.CallCtxt) {
			s, max := c.String(0), c.Int(1)
			if c.Do() {
				c.Ret = MaxRunes(s, max)
			}
		},
		"ToTitle": func(c *internal.CallCtxt) {
			s := c.String(0)
			if c.Do() {
				c.Ret = ToTitle(s)
			}
		},
		"ToCamel": func(c *internal.CallCtxt) {
			s := c.String(0)
			if c.Do() {
				c.Ret = ToCamel(s)
			}
		},
		"SliceRunes": func(c *internal.CallCtxt) {
			s, start, end := c.String(0), c.Int(1), c.Int(2)
			if c.Do() {
				c.Ret, c.Err = SliceRunes(s, start, end)
			}
		},
		"Compare": func(c *internal.CallCtxt) {
			a, b := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = Compare(a, b)
			}
		},
		"Count": func(c *internal.CallCtxt) {
			s, substr := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = Count(s, substr)
			}
		},
		"Contains": func(c *internal.CallCtxt) {
			s, substr := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = Contains(s, substr)
			}
		},
		"ContainsAny": func(c *internal.CallCtxt) {
			s, chars := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = ContainsAny(s, chars)
			}
		},
		"LastIndex": func(c *internal.CallCtxt) {
			s, substr := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = LastIndex(s, substr)
			}
		},
		"IndexAny": func(c *internal.CallCtxt) {
			s, chars := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = IndexAny(s, chars)
			}
		},
		"LastIndexAny": func(c *internal.CallCtxt) {
			s, chars := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = LastIndexAny(s, chars)
			}
		},
		"SplitN": func(c *internal.CallCtxt) {
			s, sep, n := c.String(0), c.String(1), c.Int(2)
			if c.Do() {
				c.Ret = SplitN(s, sep, n)
			}
		},
		"SplitAfterN": func(c *internal.CallCtxt) {
			s, sep, n := c.String(0), c.String(1), c.Int(2)
			if c.Do() {
				c.Ret = SplitAfterN(s, sep, n)
			}
		},
		"Split": func(c *internal.CallCtxt) {
			s, sep := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = Split(s, sep)
			}
		},
		"SplitAfter": func(c *internal.CallCtxt) {
			s, sep := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = SplitAfter(s, sep)
			}
		},
		"Fields": func(c *internal.CallCtxt) {
			s := c.String(0)
			if c.Do() {
				c.Ret = Fields(s)
			}
		},
		"Join": func(c *internal.CallCtxt) {
			elems, sep := c.StringList(0), c.String(1)
			if c.Do() {
				c.Ret = Join(elems, sep)
			}
		},
		"HasPrefix": func(c *internal.CallCtxt) {
			s, prefix := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = HasPrefix(s, prefix)
			}
		},
		"HasSuffix": func(c *internal.CallCtxt) {
			s, suffix := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = HasSuffix(s, suffix)
			}
		},
		"Repeat": func(c *internal.CallCtxt) {
			s, count := c.String(0), c.Int(1)
			if c.Do() {
				c.Ret = Repeat(s, count)
			}
		},
		"ToUpper": func(c *internal.CallCtxt) {
			s := c.String(0)
			if c.Do() {
				c.Ret = ToUpper(s)
			}
		},
		"ToLower": func(c *internal.CallCtxt) {
			s := c.String(0)
			if c.Do() {
				c.Ret = ToLower(s)
			}
		},
		"Trim": func(c *internal.CallCtxt) {
			s, cutset := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = Trim(s, cutset)
			}
		},
		"TrimLeft": func(c *internal.CallCtxt) {
			s, cutset := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = TrimLeft(s, cutset)
			}
		},
		"TrimRight": func(c *internal.CallCtxt) {
			s, cutset := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = TrimRight(s, cutset)
			}
		},
		"TrimSpace": func(c *internal.CallCtxt) {
			s := c.String(0)
			if c.Do() {
				c.Ret = TrimSpace(s)
			}
		},
		"TrimPrefix": func(c *internal.CallCtxt) {
			s, prefix := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = TrimPrefix(s, prefix)
			}
		},
		"TrimSuffix": func(c *internal.CallCtxt) {
			s, suffix := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = TrimSuffix(s, suffix)
			}
		},
		"Replace": func(c *internal.CallCtxt) {
			s, old, new, n := c.String(0), c.String(1), c.String(2), c.Int(3)
			if c.Do() {
				c.Ret = Replace(s, old, new, n)
			}
		},
		"Index": func(c *internal.CallCtxt) {
			s, substr := c.String(0), c.String(1)
			if c.Do() {
				c.Ret = Index(s, substr)
			}
		},
	},
	CUE: cueDecls,
}
